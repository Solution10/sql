# Querying

This section of the documentation will take you through how to build up queries, be they
Select, Insert, Update or Delete. But first, a little background so you can understand how it
all fits together.

## Contents

- [Fluency](#fluency)
- [Understanding Traits Used](#understanding-traits-used)
- [SELECT](#select)
- [UPDATE](#update)
- [DELETE](#delete)

## Fluency

S10\SQL aims to provide as fluent and logical interface to building queries as possible.

To that end, it ensures the following:

- All methods can be chained
- All methods can be used as getters, or setters depending on input parameters

## Understanding Traits Used

S10\SQL makes heavy use of Traits to share functionality between different Query types. The Traits
that are defined are:

| Trait | Description |
|---------------------|
| Where | Used for Selects, Updates and Deletes, this trait allows you to specify conditions in a query (WHERE ... portions). |
| Having | Used for Selects, this uses the same engine as Where, allowing the same complex conditions for HAVING |
| Pagination | Offers LIMIT and OFFSET defining functions, in an database provider safe way |
| TableName | Used for Insert, Update and Delete to specify the name of the table we're operating on |
| Values | Used for Insert and Update, allows the safe application of input to a query |

Extracting the top of the Select classes source code, you can see these traits at work:

```php
class Select extends Query
{
    use Where;
    use Having;
    use Paginate;
...
}
```

What this means is wherever you see where(), or having(), or values(), it's **the same function being called**. Which means
all the power of SELECT where() conditions are applied to any other query that uses them (like Update for instance).

## SELECT

The query that you're likely to use most often. Here's a basic example:

```php
$query = (new Solution10\SQL\Select())
    ->select('*')
    ->from('users')
    ->limit(25);
```

And here's a complex one:

```php
$query = (new Solution10\SQL\Select)
    ->select('*')
    ->from('users')
    ->join('locations', 'users.location_id', '=', 'locations.id')
    ->where('users.name', '=', 'Alex')
    ->orWhere('users.name', '=', 'Lucie')
    ->where(function (ConditionBuilder $query) {
        $query
            ->andWith('locations.city', '=', 'London')
            ->andWith('locations.country', '=', 'GB');
    })
    ->orWhere(function (ConditionBuilder $query) {
        $query
            ->andWith('locations.city', '=', 'Toronto')
            ->andWith('locations.country', '=', 'CA')
            ->orWith(function (ConditionBuilder $query) {
                $query->andWith('users.active', '!=', true);
            });
    })
    ->orderBy('name', 'ASC')
    ->limit(25)
    ->offset(5)
;
```

And that one isn't even using HAVING or GROUP BY! Hopefully you can see the kind of power at your
disposal though, nested WHERE conditions, pagination and JOINs are all available. The SQL generated by
that monster incidentally looks like this:

```sql
SELECT *
FROM "users"
JOIN "locations" ON "users"."location_id" = "locations"."id"
WHERE
    "users"."name" = ?
    OR "users"."name" = ?
    AND (
        "locations"."city" = ?
        AND "locations"."country" = ?
    )
    OR (
        "locations"."city" = ?
        AND "locations"."country" = ?
        OR (
            "users"."active" != ?
        )
    )
ORDER BY "name" ASC
LIMIT 5, 25
```

You'll notice that the limit() and offset() have been combined into the SQL standard {offset},{limit} format
and all of the table + column names have been appropriately quoted.
